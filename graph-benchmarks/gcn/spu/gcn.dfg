Input32: feat[16]  # 80 64-byte inputs is correct
Input32: offset_list0
Input32: offset_list1
Input32: acc_ctrl
# Input32: factor # feat_len/vec_len

# 16 vertices, 40 edges
# per threads, 8 vertices, 28, and 12 edges
row_size = Sub32(offset_list1, offset_list0)

# TODO: this should be data-dependent constant

# for each vertex
# max_req_inst = Mul32(row_size, factor) # factor*degree
# early_start = Sub32(max_req_inst, factor)
# 
# cur_inst = Acc32(1) #FIXME: series of numbers
# acc_ctrl = ICmp32(cur_inst, early_start)

# acc_ctrl = ICmpNE32(cur_inst, req_inst)
# acc_ctrl should be 0 for factor-1 and then 1

#acc_ctrl=2 when cur_inst=max_req_inst (TODO: leave for now)
#acc_ctrl=1 when cur_inst>=early_start
#0 otherwise

# is this a problem of reset or invalid?
# discard when all inputs not done, reset when last lot is being sent
acc_sum0 = Acc32(feat0, control=acc_ctrl{0:d,2:r})
acc_sum1 = Acc32(feat1, control=acc_ctrl{0:d,2:r})
acc_sum2 = Acc32(feat2, control=acc_ctrl{0:d,2:r})
acc_sum3 = Acc32(feat3, control=acc_ctrl{0:d,2:r})
acc_sum4 = Acc32(feat4, control=acc_ctrl{0:d,2:r})
acc_sum5 = Acc32(feat5, control=acc_ctrl{0:d,2:r})
acc_sum6 = Acc32(feat6, control=acc_ctrl{0:d,2:r})
acc_sum7 = Acc32(feat7, control=acc_ctrl{0:d,2:r})
acc_sum8 = Acc32(feat8, control=acc_ctrl{0:d,2:r})
acc_sum9 = Acc32(feat9, control=acc_ctrl{0:d,2:r})
acc_sum10 = Acc32(feat10, control=acc_ctrl{0:d,2:r})
acc_sum11 = Acc32(feat11, control=acc_ctrl{0:d,2:r})
acc_sum12 = Acc32(feat12, control=acc_ctrl{0:d,2:r})
acc_sum13 = Acc32(feat13, control=acc_ctrl{0:d,2:r})
acc_sum14 = Acc32(feat14, control=acc_ctrl{0:d,2:r})
acc_sum15 = Acc32(feat15, control=acc_ctrl{0:d,2:r})

# 25*8 acc_sum items
# 25*4 alpha items

alpha0 = acc_sum0 acc_sum1
alpha1 = acc_sum2 acc_sum3
alpha2 = acc_sum4 acc_sum5
alpha3 = acc_sum6 acc_sum7
alpha4 = acc_sum8 acc_sum9
alpha5 = acc_sum10 acc_sum11
alpha6 = acc_sum12 acc_sum13
alpha7 = acc_sum14 acc_sum15


start_ind = offset_list0

Output32: start_ind
Output32: row_size
# Output32: acc_sum[8]
Output: alpha[8]
