#include <cstdio>
#include <cstdint>
#include <cstdlib>
#include "../Common/utils.h"
#include "../Common/test.h"

#ifndef N
#define N 128
#endif

#ifndef U
#define U 1
#endif

void kernel(int64_t n_cols[], int64_t m_cols[], int64_t m_val[],
            int64_t n_v, int64_t v_cols[], int64_t v_val[], int64_t res[]) {

  #pragma ss config
  {
    //for (int64_t _ = 0; _ < 1; _ += 1) {
      {
        int64_t i = 0;
        double sum = 0;
        #pragma ss stream
        #pragma ss dfg dedicated unroll(U)
        for (int64_t j0 = n_cols[i], j1 = 0; j0 < n_cols[i + 1] - 1 && j1 < n_v - 1; ) {
          if (m_cols[j0] == v_cols[j1]) {
            sum += m_val[j0] * v_val[j1];
            ++j0;
            ++j1;
          } else {
            m_cols[j0] < v_cols[j1] ? ++j0 : ++j1;
          }
        }
        res[i] = sum;
      }
      //{
      //  int64_t i = _ + 1;
      //  double sum = 0;
      //  #pragma ss stream
      //  #pragma ss dfg dedicated
      //  for (int64_t j0 = n_cols[i], j1 = 0; j0 < n_cols[i + 1] && j1 < n_v; ) {
      //    if (m_cols[j0] == v_cols[j1]) {
      //      sum += m_val[j0] * v_val[j1];
      //      ++j0;
      //      ++j1;
      //    } else {
      //      m_cols[j0] < v_cols[j1] ? ++j0 : ++j1;
      //    }
      //  }
      //  res[i] = sum;
      //}
    //}
  }

}

int64_t atomic[N];
int64_t n_cols[N + 1];
int64_t m_cols[N * N];
int64_t m_val[N * N];

int64_t n_v;
int64_t v_cols[N];
int64_t v_val[N];
int64_t res[N];

int main() {

  n_v = rand() % N + 1;
  for (int i = 0; i < N; ++i)
    atomic[i] = i;

  random_shuffle(N, atomic);
  merge_sort(n_v, atomic);
  for (int i = 0; i < n_v; ++i) {
    v_cols[i] = atomic[i];
    v_val[i] = rand();
  }
  v_cols[n_v] = 1ull << 63;
  v_val[n_v] = 0;

  int64_t total = 0;
  for (int i = 0; i < N; ++i) {
    n_cols[i] = total;
    int n = rand() % N + 1;
    random_shuffle(N, atomic);
    merge_sort(n, atomic);
    for (int j = 0; j < n; ++j) {
      m_cols[j + total] = atomic[j];
      m_val[j + total] = rand();
    }
    m_cols[total + n] = 1ull << 63;
    m_val[total + n] = 0;
    total += n + 1;
  }
  n_cols[N] = total;


  kernel(n_cols, m_cols, m_val, n_v, v_cols, v_val, res);
  begin_roi();
  kernel(n_cols, m_cols, m_val, n_v, v_cols, v_val, res);
  end_roi();
  sb_stats();

  return 0;
}
